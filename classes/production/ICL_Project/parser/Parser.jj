options {
  STATIC=false;
}

PARSER_BEGIN(Parser)

package parser;
import ast.*;
import java.util.ArrayList;
import java.util.List;

public class Parser {

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN :
{
  < Num: (["0"-"9"]) + >
  |
  < PLUS : "+" >
  |
  < MINUS : "-">
  |
  < TIMES : "*">
  |
  < DIV : "/">
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  < EL: "\n" >
  |
  < EQ: "=" >
  |
  < NEQ: "!=" >
  |
  < AND: "&&" >
  |
  < OR: "||" >
  |
  < NEG: "~" >
  |
  < GR: ">" >
  |
  < LR: "<" >
  |
  < GRE: ">=" >
  |
  < LRE: "<=" >
  |
  < TRUE: "true" >
  |
  < FALSE: "false" >
  |
  < LET: "let" >
  |
  < IN: "in" >
  |
  < IF: "if" >
  |
  < THEN: "then" >
  |
  < ELSE: "else" >
  |
  < WHILE: "while" >
  |
  < DO: "do" >
  |
  < END: "end" >
  |
  < SEMICOLON: ";" >
  |
  < REF: ":=" >
  |
  < REREF: "::=" >
  |
  < DEREF: "!" >
  |
  < NEW: "new" >
  |
  < PRINT: "print" >
  |
  < PRINTLN: "println" >
  |
  < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
}

Exp Start():
{ Exp e; }
{
   e = statement() <EL>  { return e; }
}

Exp statement():
{ Exp e; }
{
    e = decl()
    | e = whileStatement()
    | e = ifStatement()
    | e = seq()
    | e = boolExp()
    { return e; }
}

Exp decl():
{ List<Exp> bindings = new ArrayList<Exp>();Token id; Exp e, e1, e2; }
{
  <LET> (
    id = <Id> <EQ> e1 = expr()  { bindings.add(e1); }
  )+ <IN> e2 = expr() {
    ASTLet letExpr = new ASTLet();
    letExpr.setBindings(bindings);
    letExpr.setBody(e2);
    e = letExpr;
    return letExpr;
    }
    <END>

}

//Exp decl():
//{ List<Exp> bindings = new ArrayList<Exp>();Token id; Exp e, e1, e2; }
//{
//  <LET> (
//    id = <Id> <EQ> e1 = expr() { bindings.add(new ASTId(id.image, e1)); }
//  )+ <IN> e2 = statement() {
//    ASTLet letExpr = new ASTLet();
//    letExpr.setBindings(bindings);
//    letExpr.setBody(e2);
//    e = letExpr;
//    return e;
//    }
//    <END>
//
//}

//not tested from here
//makes more sense for these expressions to be inside declarations then the opposite
Exp whileStatement():
{ Exp cond, doStatement; }
{
  < WHILE > cond = boolExp() < DO > doStatement = seq() < END >{ return new ASTWhile(cond, doStatement); }
}

Exp ifStatement():
{ Exp cond, thenPart; Exp elsePart = null; }
 {
    < IF > cond = boolExp() <THEN > thenPart = seq() (< ELSE > elsePart = seq())?
    <END> { return new ASTIf(cond, thenPart, elsePart); }
 }


//Sequential instructions should be added around here i think
//Referencing too

Exp seq():
{ Exp e1, e2; }
{
	e1 = ref() (
	  <SEMICOLON> e2 = seq() { e1 = new ASTSeq(e1, e2); }
	)?
	{ return e1; }
}

//assigns/reassigns a reference or creates a new reference
Exp ref():
{ Exp e1; Token x, y; }
{

  (x = <Id>) (<REF> e1 = expr() | <REREF> e1 = expr() | <EQ> e1 = expr()) { return new ASTRef(x.image, e1); }
  |
  <NEW> (x = <Id>) {return new ASTRef(x.image, null);}
}

// should return the address of token
Exp deref():
{ Token x; }
{
   <DEREF> x = <Id> { return new ASTDeref(x.image); }
}
// Not tested until here

// describes boolean expressions
Exp boolExp():
{ Exp e1, e2; }
{
  <NEG> e1 = expr() { return new ASTNeg(e1); }
  |
  e1 = cmp() (
	<AND> e2 = cmp() { e1 = new ASTAnd(e1, e2); }
	| <OR> e2 = cmp() { e1 = new ASTOr(e1, e2); } )*
	 { return e1; }
}

Exp bool():
{Token x, y; Exp e;}
{
    x = <TRUE> { return new ASTBool(true); }
     |
    x = <FALSE> { return new ASTBool(false); }
}

// comparison of bool values into a single bool value
Exp cmp():
{ Exp e1, e2; }
{
  e1 = expr() (
    <EQ> e2 = cmp() { e1 = new ASTEq(e1, e2); }
    | <GR> e2 = cmp() { e1 = new ASTGr(e1, e2); }
    | <LR> e2 = cmp() { e1 = new ASTGr(e2, e1); }
    | <GRE> e2 = cmp() { e1 = new ASTGrE(e1, e2); }
    | <LRE> e2 = cmp() { e1 = new ASTGrE(e2, e1); }
    | <NEQ> e2 = cmp() { e1 = new ASTNEq(e1, e2); }
  )?
  { return e1; }
}

// expr is either term value(bool,int,ref) or an addition/subtraction of terms
Exp expr() :
{ Exp e1, e2; Token op; }
{
   e1 = Term()
   (
     ( op = <PLUS> | op = <MINUS> )
     e2 = Term() { e1 = (op.kind == PLUS) ? new ASTAdd(e1, e2) : new ASTSub(e1, e2); }
   )*
   { return e1; }
}

// term is either a factor or a multiplication/division of factors
Exp Term() :
{ Exp e1, e2; Token op; }
{
     e1 = Fact()
     (
       ( op = <TIMES> | op = <DIV> )
       e2 = Fact() { e1 = (op.kind == TIMES) ? new ASTMult(e1, e2) : new ASTDiv(e1, e2); }
     )*
     { return e1; }
}

// defined by numbers or dereferenced expressions
Exp Fact() :
{ Token x; Exp e;}
{
    x = <Num> { return new ASTInt(Integer.parseInt(x.image)); }
 |
    <MINUS> x = <Num> { return new ASTInt(-Integer.parseInt(x.image)); }
 |
    e = deref() { return e; }
 |
    e = decl() { return e; }
}




